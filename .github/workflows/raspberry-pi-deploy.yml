name: Deploy to Raspberry Pi

on:
  workflow_run:
    workflows:
      - Backend CI
      - Infrastructure CI
    types:
      - completed
    branches:
      - main
      - develop
  # 수동 실행도 지원
  workflow_dispatch:
    inputs:
      deploy_specific_services:
        description: '특정 서비스만 배포 (쉼표로 구분)'
        required: false
        default: ''
        type: string
      force_restart:
        description: '전체 서비스 강제 재시작'
        required: false
        default: false
        type: boolean
      backup_before_deploy:
        description: '배포 전 데이터 백업'
        required: false
        default: true
        type: boolean
      skip_verification:
        description: '배포 후 검증 단계 건너뛰기'
        required: false
        default: false
        type: boolean

jobs:
  prepare_deployment:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    # 수정: 수동 실행 시 항상 성공, 자동 실행 시 선행 워크플로우가 성공한 경우에만 실행
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      environment: ${{ steps.set_env.outputs.environment }}
      specific_services: ${{ steps.set_env.outputs.specific_services }}
      force_restart: ${{ steps.set_env.outputs.force_restart }}
      backup_before_deploy: ${{ steps.set_env.outputs.backup_before_deploy }}
      skip_verification: ${{ steps.set_env.outputs.skip_verification }}
    steps:
      - id: set_env
        run: |
          if [[ "${{ github.event.workflow_run.head_branch || github.ref_name }}" == "main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
          fi
          
          # 수동 실행 시 입력 파라미터 처리
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "specific_services=${{ github.event.inputs.deploy_specific_services }}" >> $GITHUB_OUTPUT
            
            # 불리언 값을 문자열로 변환하여 저장
            if [[ "${{ github.event.inputs.force_restart }}" == "true" ]]; then
              echo "force_restart=true" >> $GITHUB_OUTPUT
            else
              echo "force_restart=false" >> $GITHUB_OUTPUT
            fi
            
            if [[ "${{ github.event.inputs.backup_before_deploy }}" == "true" ]]; then
              echo "backup_before_deploy=true" >> $GITHUB_OUTPUT
            else
              echo "backup_before_deploy=false" >> $GITHUB_OUTPUT
            fi
            
            if [[ "${{ github.event.inputs.skip_verification }}" == "true" ]]; then
              echo "skip_verification=true" >> $GITHUB_OUTPUT
            else
              echo "skip_verification=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "specific_services=" >> $GITHUB_OUTPUT
            echo "force_restart=false" >> $GITHUB_OUTPUT
            echo "backup_before_deploy=true" >> $GITHUB_OUTPUT
            echo "skip_verification=false" >> $GITHUB_OUTPUT
          fi
          
          # 실행 정보 출력
          echo "배포 환경: ${{ github.event.workflow_run.head_branch || github.ref_name }}"
          echo "실행 방식: ${{ github.event_name }}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "수동 배포 옵션:"
            echo " - 특정 서비스: ${{ github.event.inputs.deploy_specific_services || '없음 (전체 배포)' }}"
            echo " - 강제 재시작: ${{ github.event.inputs.force_restart }}"
            echo " - 데이터 백업: ${{ github.event.inputs.backup_before_deploy }}"
            echo " - 검증 건너뛰기: ${{ github.event.inputs.skip_verification }}"
          fi

  setup_cloudflared:
    name: Setup Cloudflared Connection
    needs: prepare_deployment
    runs-on: ubuntu-latest
    steps:
      - name: Install cloudflared and Set up SSH
        run: |
          # cloudflared 설치
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin
          cloudflared version
          
          # 시크릿에 저장된 SSH 키 사용
          mkdir -p ~/.ssh
          echo "${{ secrets.RASPBERRY_PI_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          # cloudflared로 로컬 포트 2222를 라즈베리파이 SSH 포트로 포워딩
          echo "Cloudflared TCP 포트 포워딩 설정 중..."
          nohup cloudflared access tcp --hostname pi.eumgyeol.com --url 127.0.0.1:2222 --loglevel debug > cloudflared.log 2>&1 &
          CLOUDFLARED_PID=$!
          echo "Cloudflared PID: $CLOUDFLARED_PID"
          
          # 설정 확인을 위해 대기
          sleep 5
          
          # cloudflared 상태 확인
          if ps -p $CLOUDFLARED_PID > /dev/null; then
            echo "cloudflared 프로세스가 실행 중입니다."
            
            # cloudflared 로그 확인
            echo "cloudflared 로그:"
            cat cloudflared.log || echo "로그 파일이 없습니다."
            
            # SSH 설정 - 로컬 포트로 연결
            cat > ~/.ssh/config << EOF
          Host raspberry-pi
            HostName localhost
            Port 2222
            User ${{ secrets.RASPBERRY_PI_USER }}
            IdentityFile ~/.ssh/id_ed25519
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel DEBUG3
          EOF
            chmod 600 ~/.ssh/config
          else
            echo "cloudflared 프로세스 시작 실패"
            cat cloudflared.log || echo "로그 파일이 없습니다"
            exit 1
          fi
      
      - name: Test SSH Connection
        id: ssh_test
        run: |
          echo "SSH 연결 테스트 중..."
          
          # SSH 키 기반 인증으로 연결 시도
          if ssh -o ConnectTimeout=10 raspberry-pi 'echo "Connection successful" && uptime'; then
            echo "ssh_connected=true" >> $GITHUB_OUTPUT
          else
            echo "ssh_connected=false" >> $GITHUB_OUTPUT
            echo "연결 실패. 자세한 로그:"
            ssh -vvv raspberry-pi 'echo test' || true
            cat cloudflared.log || echo "cloudflared 로그 파일이 없습니다."
            exit 1
          fi

  check_raspberry_pi:
    name: Check Raspberry Pi Health
    needs: [prepare_deployment, setup_cloudflared]
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Connection Again
        run: |
          # 이전 cloudflared 프로세스 종료
          pkill cloudflared || echo "실행 중인 cloudflared 프로세스가 없습니다"
          
          # cloudflared 설치
          echo "cloudflared 설치 중..."
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin
          cloudflared version
          
          # SSH 디렉토리 확인 및 생성
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # SSH 키 확인 (이미 있으면 다시 생성하지 않음)
          if [ ! -f ~/.ssh/id_ed25519 ]; then
            echo "${{ secrets.RASPBERRY_PI_SSH_KEY }}" > ~/.ssh/id_ed25519
            chmod 600 ~/.ssh/id_ed25519
          fi
          
          # 새 cloudflared TCP 터널 설정
          echo "Cloudflared TCP 포트 포워딩 설정 중..."
          nohup cloudflared access tcp --hostname pi.eumgyeol.com --url 127.0.0.1:2222 --loglevel debug > cloudflared_again.log 2>&1 &
          CLOUDFLARED_PID=$!
          echo "Cloudflared PID: $CLOUDFLARED_PID"
          
          # 설정 확인을 위해 대기
          sleep 5
          
          # cloudflared 상태 확인
          if ps -p $CLOUDFLARED_PID > /dev/null; then
            echo "cloudflared 프로세스가 실행 중입니다."
            
            # cloudflared 로그 확인
            echo "cloudflared 로그:"
            cat cloudflared_again.log || echo "로그 파일이 없습니다."
            
            # SSH 설정 - 로컬 포트로 연결
            cat > ~/.ssh/config << EOF
          Host raspberry-pi
            HostName localhost
            Port 2222
            User ${{ secrets.RASPBERRY_PI_USER }}
            IdentityFile ~/.ssh/id_ed25519
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel DEBUG3
          EOF
            chmod 600 ~/.ssh/config
          else
            echo "cloudflared 프로세스 시작 실패"
            cat cloudflared_again.log || echo "로그 파일이 없습니다"
            exit 1
          fi
          
      - name: Test SSH Connection
        run: |
          echo "SSH 연결 테스트 중..."
          
          # SSH 키 기반 인증으로 연결 시도 
          if ssh -o ConnectTimeout=10 raspberry-pi 'echo "Connection successful" && uptime'; then
            echo "SSH 연결 성공"
          else
            echo "SSH 연결 실패. 자세한 로그:"
            ssh -vvv raspberry-pi 'echo test' || true
            cat cloudflared_again.log || echo "cloudflared 로그 파일이 없습니다."
            exit 1
          fi
          
      - name: Setup Docker Authentication on Raspberry Pi
        run: |
          # GitHub Container Registry 인증 설정
          echo "GitHub Container Registry 인증 설정 중..."
          
          # 인증 정보 전송
          echo "${{ secrets.GITHUB_TOKEN }}" | ssh raspberry-pi "cat > ~/.github_token"
          
          # 라즈베리파이에서 Docker 로그인 실행
          ssh raspberry-pi '
            echo "GitHub Container Registry 인증 설정 중..."
            cat ~/.github_token | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
            rm ~/.github_token  # 보안을 위해 토큰 파일 삭제
          '
      
      - name: Check Disk Space
        id: disk_check
        run: |
          # 디스크 공간 확인
          DISK_INFO=$(ssh raspberry-pi 'df -h | grep -E "/$"')
          
          # 디스크 사용량 추출 (% 제거)
          DISK_USAGE=$(echo "$DISK_INFO" | awk '{print $5}' | sed 's/%//')
          echo "disk_usage=$DISK_USAGE" >> $GITHUB_OUTPUT
          
          # 사용 가능한 공간 확인 (MB 단위)
          AVAILABLE_SPACE=$(ssh raspberry-pi 'df -m | grep -E "/$" | awk "{print \$4}"')
          echo "available_space=${AVAILABLE_SPACE}MB" >> $GITHUB_OUTPUT
          
          # 최소 필요 공간: 500MB
          if [ "$AVAILABLE_SPACE" -lt 500 ]; then
            echo "disk_warning=true" >> $GITHUB_OUTPUT
          else
            echo "disk_warning=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Check RAM
        id: ram_check
        run: |
          # 메모리 정보 확인
          RAM_INFO=$(ssh raspberry-pi 'free -m | grep "Mem:"')
          
          # 사용 가능한 메모리 추출 (MB)
          AVAILABLE_RAM=$(echo "$RAM_INFO" | awk '{print $7}')
          echo "available_ram=${AVAILABLE_RAM}MB" >> $GITHUB_OUTPUT
          
          # 최소 필요 메모리: 200MB
          if [ "$AVAILABLE_RAM" -lt 200 ]; then
            echo "ram_warning=true" >> $GITHUB_OUTPUT
          else
            echo "ram_warning=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Display Resource Info
        run: |
          echo "디스크 사용량: ${{ steps.disk_check.outputs.disk_usage }}%"
          echo "사용 가능한 디스크 공간: ${{ steps.disk_check.outputs.available_space }}"
          echo "사용 가능한 메모리: ${{ steps.ram_check.outputs.available_ram }}"
      
      - name: Clean Up if Necessary
        if: steps.disk_check.outputs.disk_warning == 'true'
        run: |
          echo "디스크 공간 부족, 정리 작업 수행 중..."
          ssh raspberry-pi '
            # 미사용 도커 리소스 정리
            docker system prune -af --volumes
            
            # 로그 파일 정리
            find /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk -name "*.log" -type f -exec rm -f {} \;
            
            # 임시 파일 삭제
            sudo find /tmp -type f -atime +5 -delete
          '
          
          # 정리 후 디스크 공간 다시 확인
          DISK_USAGE_AFTER=$(ssh raspberry-pi 'df -h | grep -E "/$" | awk "{print \$5}" | sed "s/%//"')
          
          echo "정리 후 디스크 사용량: ${DISK_USAGE_AFTER}%"

  backup_data:
    name: Backup Data
    needs: [prepare_deployment, setup_cloudflared, check_raspberry_pi]
    runs-on: ubuntu-latest
    if: needs.prepare_deployment.outputs.backup_before_deploy == 'true'
    steps:
      - name: Setup SSH Connection Again
        run: |
          # 이전 cloudflared 프로세스 종료
          pkill cloudflared || echo "실행 중인 cloudflared 프로세스가 없습니다"
          
          # cloudflared 설치
          echo "cloudflared 설치 중..."
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin
          cloudflared version
          
          # SSH 디렉토리 확인 및 생성
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # SSH 키 확인 (이미 있으면 다시 생성하지 않음)
          if [ ! -f ~/.ssh/id_ed25519 ]; then
            echo "${{ secrets.RASPBERRY_PI_SSH_KEY }}" > ~/.ssh/id_ed25519
            chmod 600 ~/.ssh/id_ed25519
          fi
          
          # 새 cloudflared TCP 터널 설정
          echo "Cloudflared TCP 포트 포워딩 설정 중..."
          nohup cloudflared access tcp --hostname pi.eumgyeol.com --url 127.0.0.1:2222 --loglevel debug > cloudflared_again.log 2>&1 &
          CLOUDFLARED_PID=$!
          echo "Cloudflared PID: $CLOUDFLARED_PID"
          
          # 설정 확인을 위해 대기
          sleep 5
          
          # cloudflared 상태 확인
          if ps -p $CLOUDFLARED_PID > /dev/null; then
            echo "cloudflared 프로세스가 실행 중입니다."
            
            # cloudflared 로그 확인
            echo "cloudflared 로그:"
            cat cloudflared_again.log || echo "로그 파일이 없습니다."
            
            # SSH 설정 - 로컬 포트로 연결
            cat > ~/.ssh/config << EOF
          Host raspberry-pi
            HostName localhost
            Port 2222
            User ${{ secrets.RASPBERRY_PI_USER }}
            IdentityFile ~/.ssh/id_ed25519
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel DEBUG3
          EOF
            chmod 600 ~/.ssh/config
          else
            echo "cloudflared 프로세스 시작 실패"
            cat cloudflared_again.log || echo "로그 파일이 없습니다"
            exit 1
          fi
          
      - name: Test SSH Connection
        run: |
          echo "SSH 연결 테스트 중..."
          
          # SSH 키 기반 인증으로 연결 시도 
          if ssh -o ConnectTimeout=10 raspberry-pi 'echo "Connection successful" && uptime'; then
            echo "SSH 연결 성공"
          else
            echo "SSH 연결 실패. 자세한 로그:"
            ssh -vvv raspberry-pi 'echo test' || true
            cat cloudflared_again.log || echo "cloudflared 로그 파일이 없습니다."
            exit 1
          fi
      
      - name: Setup Docker Authentication on Raspberry Pi
        run: |
          # GitHub Container Registry 인증 설정
          echo "GitHub Container Registry 인증 설정 중..."
          
          # 인증 정보 전송
          echo "${{ secrets.GITHUB_TOKEN }}" | ssh raspberry-pi "cat > ~/.github_token"
          
          # 라즈베리파이에서 Docker 로그인 실행
          ssh raspberry-pi '
            echo "GitHub Container Registry 인증 설정 중..."
            cat ~/.github_token | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
            rm ~/.github_token  # 보안을 위해 토큰 파일 삭제
          '
      
      - name: Transfer Docker Compose Files
        run: |
          # 기존 docker-compose.yml 확인 및 수정
          echo "Docker Compose 파일 준비 중..."
          
          # 이미지 기반 docker-compose.yml 생성
          cat > docker-compose.yml << 'EOL'
          version: '3.8'
          
          services:
            # 데이터베이스
            postgres:
              image: postgres:14-alpine
              restart: always
              environment:
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                POSTGRES_DB: ${POSTGRES_DB}
              volumes:
                - postgres_data:/var/lib/postgresql/data
                - ./infrastructure/database/postgres/init:/docker-entrypoint-initdb.d
              ports:
                - "${POSTGRES_PORT}:5432"
          
            mongodb:
              image: mongo:6-jammy
              restart: always
              environment:
                MONGO_INITDB_ROOT_USERNAME: ${MONGO_USER}
                MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
                MONGO_INITDB_DATABASE: ${MONGO_DB}
              volumes:
                - mongodb_data:/data/db
                - ./infrastructure/database/mongodb/init:/docker-entrypoint-initdb.d
              ports:
                - "${MONGO_PORT}:27017"
          
            redis:
              image: redis:7-alpine
              restart: always
              command: redis-server --requirepass ${REDIS_PASSWORD}
              volumes:
                - redis_data:/data
              ports:
                - "${REDIS_PORT}:6379"
          
            # 메시징 시스템
            zookeeper:
              image: confluentinc/cp-zookeeper:7.4.1
              restart: always
              environment:
                ZOOKEEPER_CLIENT_PORT: ${ZOOKEEPER_PORT}
                ZOOKEEPER_TICK_TIME: 2000
          
            kafka:
              image: confluentinc/cp-kafka:7.4.1
              restart: always
              depends_on:
                - zookeeper
              environment:
                KAFKA_BROKER_ID: 1
                KAFKA_ZOOKEEPER_CONNECT: zookeeper:${ZOOKEEPER_PORT}
                KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
                KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
                KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
                KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
                KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
              ports:
                - "${KAFKA_PORT}:9092"
          
            kafka-ui:
              image: provectuslabs/kafka-ui:latest
              restart: always
              depends_on:
                - kafka
              environment:
                KAFKA_CLUSTERS_0_NAME: haptitalk
                KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092
                KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:${ZOOKEEPER_PORT}
              ports:
                - "${KAFKA_UI_PORT}:8080"
          
            kafka-init:
              image: confluentinc/cp-kafka:7.4.1
              depends_on:
                - kafka
              entrypoint: ["/bin/sh", "-c"]
              command: |
                echo "Kafka 초기화 중..."
                sleep 10
                # 필요한 토픽 생성
                kafka-topics --bootstrap-server kafka:9092 --create --if-not-exists --topic ${KAFKA_TOPIC_SESSION_EVENTS} --partitions 3 --replication-factor 1
                kafka-topics --bootstrap-server kafka:9092 --create --if-not-exists --topic ${KAFKA_TOPIC_ANALYSIS_RESULTS} --partitions 3 --replication-factor 1
                kafka-topics --bootstrap-server kafka:9092 --create --if-not-exists --topic ${KAFKA_TOPIC_FEEDBACK_COMMANDS} --partitions 3 --replication-factor 1
                kafka-topics --bootstrap-server kafka:9092 --create --if-not-exists --topic ${KAFKA_TOPIC_USER_ACTIVITY} --partitions 3 --replication-factor 1
                echo "Kafka 토픽 생성 완료"
          
            # API 게이트웨이
            kong:
              image: kong/kong:3.3.1-alpine
              platform: linux/arm64/v8
              restart: always
              environment:
                KONG_DATABASE: "off"
                KONG_DECLARATIVE_CONFIG: /usr/local/kong/declarative/kong.yml
                KONG_PROXY_ACCESS_LOG: /dev/stdout
                KONG_ADMIN_ACCESS_LOG: /dev/stdout
                KONG_PROXY_ERROR_LOG: /dev/stderr
                KONG_ADMIN_ERROR_LOG: /dev/stderr
                KONG_ADMIN_LISTEN: 0.0.0.0:8001
              volumes:
                - ./infrastructure/api-gateway:/usr/local/kong/declarative
                - kong_data:/usr/local/kong/data
              ports:
                - "${KONG_PROXY_PORT}:8000"
                - "${KONG_HTTPS_PORT}:8443"
                - "${KONG_ADMIN_PORT}:8001"
          
            # 정적 웹 서버
            static-web:
              image: nginx:1.25-alpine
              restart: always
              volumes:
                - ./infrastructure/static-web/html:/usr/share/nginx/html
                - ./infrastructure/static-web/nginx.conf:/etc/nginx/conf.d/default.conf
              ports:
                - "8080:80"
          
            # 마이크로서비스 (최신 이미지 사용)
            auth-service:
              image: ghcr.io/eumgyeol/haptitalk-auth-service:latest
              restart: always
              environment:
                PORT: ${AUTH_SERVICE_PORT}
                NODE_ENV: ${DEPLOY_ENVIRONMENT}
                JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
                JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
                JWT_ACCESS_EXPIRES_IN: ${JWT_ACCESS_EXPIRES_IN}
                JWT_REFRESH_EXPIRES_IN: ${JWT_REFRESH_EXPIRES_IN}
                POSTGRES_HOST: postgres
                POSTGRES_PORT: 5432
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                POSTGRES_DB: ${POSTGRES_DB}
                REDIS_HOST: redis
                REDIS_PORT: 6379
                REDIS_PASSWORD: ${REDIS_PASSWORD}
                LOG_LEVEL: ${LOG_LEVEL}
              depends_on:
                - postgres
                - redis
              ports:
                - "${AUTH_SERVICE_PORT}:${AUTH_SERVICE_PORT}"
          
            realtime-service:
              image: ghcr.io/eumgyeol/haptitalk-realtime-service:latest
              restart: always
              environment:
                PORT: ${REALTIME_SERVICE_PORT}
                NODE_ENV: ${DEPLOY_ENVIRONMENT}
                JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
                KAFKA_BROKERS: kafka:9092
                KAFKA_TOPIC_SESSION_EVENTS: ${KAFKA_TOPIC_SESSION_EVENTS}
                LOG_LEVEL: ${LOG_LEVEL}
              depends_on:
                - kafka
              ports:
                - "${REALTIME_SERVICE_PORT}:${REALTIME_SERVICE_PORT}"
          
            session-service:
              image: ghcr.io/eumgyeol/haptitalk-session-service:latest
              restart: always
              environment:
                PORT: ${SESSION_SERVICE_PORT}
                NODE_ENV: ${DEPLOY_ENVIRONMENT}
                JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
                JWT_SESSION_SECRET: ${JWT_SESSION_SECRET}
                JWT_SESSION_EXPIRES_IN: ${JWT_SESSION_EXPIRES_IN}
                MONGO_URI: mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}
                KAFKA_BROKERS: kafka:9092
                KAFKA_TOPIC_SESSION_EVENTS: ${KAFKA_TOPIC_SESSION_EVENTS}
                KAFKA_TOPIC_ANALYSIS_RESULTS: ${KAFKA_TOPIC_ANALYSIS_RESULTS}
                LOG_LEVEL: ${LOG_LEVEL}
              depends_on:
                - mongodb
                - kafka
              ports:
                - "${SESSION_SERVICE_PORT}:${SESSION_SERVICE_PORT}"
          
            feedback-service:
              image: ghcr.io/eumgyeol/haptitalk-feedback-service:latest
              restart: always
              environment:
                PORT: ${FEEDBACK_SERVICE_PORT}
                NODE_ENV: ${DEPLOY_ENVIRONMENT}
                JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
                POSTGRES_HOST: postgres
                POSTGRES_PORT: 5432
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                POSTGRES_DB: ${POSTGRES_DB}
                KAFKA_BROKERS: kafka:9092
                KAFKA_TOPIC_FEEDBACK_COMMANDS: ${KAFKA_TOPIC_FEEDBACK_COMMANDS}
                LOG_LEVEL: ${LOG_LEVEL}
              depends_on:
                - postgres
                - kafka
              ports:
                - "${FEEDBACK_SERVICE_PORT}:${FEEDBACK_SERVICE_PORT}"
          
            user-service:
              image: ghcr.io/eumgyeol/haptitalk-user-service:latest
              restart: always
              environment:
                PORT: ${USER_SERVICE_PORT}
                NODE_ENV: ${DEPLOY_ENVIRONMENT}
                JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
                POSTGRES_HOST: postgres
                POSTGRES_PORT: 5432
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                POSTGRES_DB: ${POSTGRES_DB}
                KAFKA_BROKERS: kafka:9092
                KAFKA_TOPIC_USER_ACTIVITY: ${KAFKA_TOPIC_USER_ACTIVITY}
                EMAIL_FROM: ${EMAIL_FROM}
                FRONTEND_URL: ${FRONTEND_URL}
                LOG_LEVEL: ${LOG_LEVEL}
              depends_on:
                - postgres
                - kafka
              ports:
                - "${USER_SERVICE_PORT}:${USER_SERVICE_PORT}"
          
            report-service:
              image: ghcr.io/eumgyeol/haptitalk-report-service:latest
              restart: always
              environment:
                PORT: ${REPORT_SERVICE_PORT}
                NODE_ENV: ${DEPLOY_ENVIRONMENT}
                JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
                MONGO_URI: mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}
                LOG_LEVEL: ${LOG_LEVEL}
              depends_on:
                - mongodb
              ports:
                - "${REPORT_SERVICE_PORT}:${REPORT_SERVICE_PORT}"
          
          volumes:
            postgres_data:
              name: ${POSTGRES_VOLUME_NAME}
            mongodb_data:
              name: ${MONGODB_VOLUME_NAME}
            redis_data:
              name: ${REDIS_VOLUME_NAME}
            kong_data:
              name: ${KONG_VOLUME_NAME}
          EOL
          
          # 라즈베리파이에 파일 전송
          scp -o StrictHostKeyChecking=no docker-compose.yml raspberry-pi:/home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/
          
          # 필요한 디렉토리 구조 생성
          ssh raspberry-pi "
            mkdir -p /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/infrastructure/database/postgres/init
            mkdir -p /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/infrastructure/database/mongodb/init
            mkdir -p /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/infrastructure/database/redis/init
            mkdir -p /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/infrastructure/api-gateway
            mkdir -p /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/infrastructure/static-web/html
          "
          
          # Kong 설정 파일 전송 (필요시)
          if [ -f "infrastructure/api-gateway/kong.yml" ]; then
            scp -o StrictHostKeyChecking=no infrastructure/api-gateway/kong.yml raspberry-pi:/home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/infrastructure/api-gateway/
          fi
          
          # .env 파일 생성 및 전송
          cat > .env << EOL
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_VOLUME_NAME=postgres_data
          POSTGRES_PORT=5432
          
          MONGO_USER=${{ secrets.MONGO_USER }}
          MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }}
          MONGO_DB=${{ secrets.MONGO_DB }}
          MONGODB_VOLUME_NAME=mongodb_data
          MONGO_PORT=27017
          
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          REDIS_VOLUME_NAME=redis_data
          REDIS_PORT=6379
          
          ZOOKEEPER_PORT=2181
          KAFKA_PORT=9092
          KAFKA_UI_PORT=8080
          
          KONG_PROXY_PORT=8000
          KONG_HTTPS_PORT=8443
          KONG_ADMIN_PORT=8001
          KONG_VOLUME_NAME=kong_data
          
          JWT_ACCESS_SECRET=${{ secrets.JWT_ACCESS_SECRET }}
          JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
          JWT_SESSION_SECRET=${{ secrets.JWT_SESSION_SECRET }}
          JWT_ACCESS_EXPIRES_IN=15m
          JWT_REFRESH_EXPIRES_IN=7d
          JWT_SESSION_EXPIRES_IN=30d
          
          KAFKA_TOPIC_SESSION_EVENTS=session-events
          KAFKA_TOPIC_ANALYSIS_RESULTS=analysis-results
          KAFKA_TOPIC_FEEDBACK_COMMANDS=feedback-commands
          KAFKA_TOPIC_USER_ACTIVITY=user-activity
          
          AUTH_SERVICE_PORT=3000
          REALTIME_SERVICE_PORT=3001
          SESSION_SERVICE_PORT=3002
          FEEDBACK_SERVICE_PORT=3003
          USER_SERVICE_PORT=3004
          REPORT_SERVICE_PORT=3005
          
          LOG_LEVEL=info
          FRONTEND_URL=http://${{ secrets.RASPBERRY_PI_IP }}:8080
          EMAIL_FROM=no-reply@haptitalk.com
          
          # 라즈베리파이 배포 관련 추가 설정
          DEPLOY_VERSION=$(date +%Y%m%d%H%M%S)
          DEPLOY_ENVIRONMENT=${{ needs.prepare_deployment.outputs.environment }}
          EOL
          
          scp -o StrictHostKeyChecking=no .env raspberry-pi:/home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/
          
          # 인프라스트럭처 디렉토리 전송
          scp -o StrictHostKeyChecking=no -r infrastructure raspberry-pi:/home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/
          
          # 배포 스크립트 생성 및 전송
          cat > deploy.sh << 'EOL'
          #!/bin/bash
          set -e
          
          # 배포 로그 시작
          DEPLOY_LOG="/home/${USER}/haptitalk/logs/deploy_$(date +%Y%m%d_%H%M%S).log"
          mkdir -p /home/${USER}/haptitalk/logs
          
          echo "===== 배포 시작: $(date) =====" | tee -a $DEPLOY_LOG
          cd /home/${USER}/haptitalk
          
          # 디렉토리 구조 확인
          mkdir -p infrastructure/database/postgres/init
          mkdir -p infrastructure/database/mongodb/init
          mkdir -p infrastructure/database/redis/init
          mkdir -p infrastructure/api-gateway
          mkdir -p infrastructure/messaging/kafka/init
          mkdir -p infrastructure/static-web/html
          
          # 이미지 가져오기
          echo "도커 이미지 업데이트 중..." | tee -a $DEPLOY_LOG
          # 이미지 풀 오류시 계속 진행 (일부 실패해도 진행)
          docker-compose pull || echo "일부 이미지를 가져오지 못했습니다. 계속 진행합니다." | tee -a $DEPLOY_LOG
          
          # 기존 컨테이너 상태 저장 (롤백용)
          echo "현재 컨테이너 상태 백업 중..." | tee -a $DEPLOY_LOG
          docker-compose ps > /home/${USER}/haptitalk/container_state_before_deploy.txt || true
          
          # 특정 서비스만 재시작 여부 확인
          SPECIFIC_SERVICES="$1"
          FORCE_RESTART="$2"
          
          # 도커 네트워크 생성 (없으면)
          docker network create haptitalk_network 2>/dev/null || echo "네트워크가 이미 존재합니다."
          
          # 실제 배포 시작
          echo "배포 시작..." | tee -a $DEPLOY_LOG
          
          if [ "$FORCE_RESTART" == "true" ]; then
            echo "강제 재시작 모드: 모든 컨테이너를 중지하고 재시작합니다." | tee -a $DEPLOY_LOG
            docker-compose down --remove-orphans
            docker-compose up -d
          elif [ -n "$SPECIFIC_SERVICES" ]; then
            echo "특정 서비스만 재시작: $SPECIFIC_SERVICES" | tee -a $DEPLOY_LOG
            IFS=',' read -ra SERVICES <<< "$SPECIFIC_SERVICES"
            for service in "${SERVICES[@]}"; do
              echo "서비스 재시작: $service" | tee -a $DEPLOY_LOG
              # 서비스 존재 여부 확인 후 재시작
              if grep -q "$service:" docker-compose.yml; then
                docker-compose stop $service || true
                docker-compose rm -f $service || true
                docker-compose up -d $service
              else
                echo "경고: $service 서비스가 docker-compose.yml에 정의되어 있지 않습니다." | tee -a $DEPLOY_LOG
              fi
            done
          else
            echo "인프라 서비스 배포 중..." | tee -a $DEPLOY_LOG
            # 기본 인프라 서비스만 시작
            docker-compose up -d postgres mongodb redis zookeeper kafka kafka-ui kafka-init kong static-web
            
            echo "애플리케이션 서비스 배포 중..." | tee -a $DEPLOY_LOG
            # 각 서비스 개별 시작 (오류 격리)
            for service in auth-service realtime-service session-service feedback-service user-service report-service; do
              echo "서비스 시작: $service" | tee -a $DEPLOY_LOG
              docker-compose up -d $service || echo "경고: $service 시작 실패" | tee -a $DEPLOY_LOG
            done
          fi
          
          # 배포 완료 확인
          echo "컨테이너 상태:" | tee -a $DEPLOY_LOG
          docker-compose ps | tee -a $DEPLOY_LOG
          
          # 실행 중인 컨테이너 수 확인
          RUNNING_COUNT=$(docker-compose ps --services --filter "status=running" | wc -l)
          echo "실행 중인 컨테이너 수: $RUNNING_COUNT" | tee -a $DEPLOY_LOG
          
          echo "===== 배포 완료: $(date) =====" | tee -a $DEPLOY_LOG
          EOL
          
          chmod +x deploy.sh
          scp -o StrictHostKeyChecking=no deploy.sh raspberry-pi:/home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk/
      
      - name: Create Docker Network
        run: |
          ssh raspberry-pi '
            docker network create haptitalk_network || echo "Network already exists"
          '
      
      - name: Deploy Services
        id: deploy
        run: |
          # 배포 실행
          SPECIFIC_SERVICES="${{ needs.prepare_deployment.outputs.specific_services }}"
          FORCE_RESTART="${{ needs.prepare_deployment.outputs.force_restart }}"
          
          # GitHub Container Registry 인증 설정
          echo "GitHub Container Registry 인증 설정 중..."
          echo "${{ secrets.GHCR_PAT }}" | ssh raspberry-pi "cat > ~/.github_token"
          
          ssh raspberry-pi "
            # Docker 로그인 실행
            echo \"GitHub Container Registry 로그인 중...\"
            cat ~/.github_token | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
            rm ~/.github_token  # 보안을 위해 토큰 파일 삭제
            
            # Kong 이미지 수정 (ARM 호환성 문제 해결)
            cd /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk
            sed -i 's|image: kong:3.3.1-alpine|image: kong/kong:3.3.1-alpine\\n    platform: linux/arm64/v8|g' docker-compose.yml 2>/dev/null || true
            
            # 배포 실행
            ./deploy.sh \"$SPECIFIC_SERVICES\" \"$FORCE_RESTART\"
          "
      
      - name: Get Current Time
        id: current_time
        run: echo "time=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_OUTPUT
      
      - name: Verify Deployment
        id: verify
        run: |
          # 배포 검증
          VERIFICATION=$(ssh raspberry-pi '
            cd /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk
            
            # 주요 서비스 상태 확인
            echo "===== 서비스 상태 ====="
            docker-compose ps
            
            # 서비스별 Health Check
            echo "===== 헬스 체크 ====="
            POSTGRES_HEALTH=$(docker-compose exec -T postgres pg_isready 2>/dev/null && echo "OK" || echo "FAIL")
            echo "PostgreSQL: $POSTGRES_HEALTH"
            
            REDIS_HEALTH=$(docker-compose exec -T redis redis-cli -a "$REDIS_PASSWORD" ping 2>/dev/null && echo "OK" || echo "FAIL")
            echo "Redis: $REDIS_HEALTH"
            
            KONG_HEALTH=$(docker-compose exec -T kong kong health 2>/dev/null && echo "OK" || echo "FAIL")
            echo "Kong: $KONG_HEALTH"
            
            # 최근 로그 확인 (오류 여부)
            echo "===== 최근 오류 로그 ====="
            docker-compose logs --tail=50 | grep -i "error\|exception\|fatal" || echo "최근 오류 없음"
          ')
          
          echo "$VERIFICATION"
          
          # 주요 서비스가 정상적으로 실행 중인지 확인
          if echo "$VERIFICATION" | grep -q "FAIL"; then
            echo "deploy_success=false" >> $GITHUB_OUTPUT
            echo "verification_result=일부 서비스가 정상 작동하지 않습니다." >> $GITHUB_OUTPUT
          else
            echo "deploy_success=true" >> $GITHUB_OUTPUT
            echo "verification_result=모든 서비스가 정상 작동합니다." >> $GITHUB_OUTPUT
          fi
      
      - name: Rollback if Necessary
        if: steps.verify.outputs.deploy_success == 'false'
        run: |
          echo "배포 검증 실패, 롤백을 진행합니다..."
          
          ssh raspberry-pi '
            cd /home/${{ secrets.RASPBERRY_PI_USER }}/haptitalk
            
            # 이전 상태로 롤백
            echo "===== 롤백 시작 ====="
            docker-compose down --remove-orphans
            
            # 이전 이미지로 롤백 (가장 최근 태그가 아닌 이전 태그 사용)
            DEPLOY_VERSION=$(date +%Y%m%d)
            if [ -f ".env.prev" ]; then
              cp .env.prev .env
            fi
            
            # 서비스 재시작
            docker-compose up -d
            
            echo "===== 롤백 완료 ====="
            docker-compose ps
          '
      
      - name: Send Deployment Notification
        if: always()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL || 'deployments' }}
          SLACK_COLOR: ${{ (steps.verify.outputs.deploy_success == 'false' && 'danger') || job.status }}
          SLACK_TITLE: Raspberry Pi Deployment - ${{ needs.prepare_deployment.outputs.environment }}
          SLACK_MESSAGE: |
            *라즈베리파이 배포 결과*
            
            *환경:* ${{ needs.prepare_deployment.outputs.environment }}
            *상태:* ${{ steps.verify.outputs.deploy_success == 'false' && '❌ 배포 실패 (롤백 완료)' || '✅ 배포 성공' }}
            *배포 서비스:* ${{ needs.prepare_deployment.outputs.specific_services || '전체 서비스' }}
            *강제 재시작:* ${{ needs.prepare_deployment.outputs.force_restart }}
            
            *검증 결과:* ${{ steps.verify.outputs.verification_result || '검증 정보 없음' }}
            
            *디스크 공간:* ${{ steps.disk_check.outputs.disk_usage }}% 사용 (가용: ${{ steps.disk_check.outputs.available_space }})
            *메모리:* 가용 ${{ steps.ram_check.outputs.available_ram }}
            *배포 시간:* ${{ steps.current_time.outputs.time }}
          SLACK_FOOTER: 'HaptiTalk CI/CD'
        continue-on-error: true
